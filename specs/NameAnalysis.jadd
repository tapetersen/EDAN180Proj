import semanticlib.SymbolTable;
import semantic.*;

aspect NameAnalysis {
	
	public void Start.nameAnalysis(Semantic s) {
		SymbolTable<String, IdDecl> table = new SymbolTable<String, IdDecl>();
		table.enterBlock();
		nameAnalysis(table, s);
		table.exitBlock(); // pedantic
		
		
		SymbolTable<String, Procedure> procTable = new SymbolTable<String, Procedure>();
		
		// gather toplevel procedures
		procTable.enterBlock();
		gatherProcedures(procTable, s);
		procAnalysis(procTable, s);
		procTable.exitBlock();
	}
	
	void ASTNode.nameAnalysis(SymbolTable<String, IdDecl> table, Semantic s) {
		for (int k=0; k<getNumChild(); k++) {
			getChild(k).nameAnalysis(table, s);
		}
	}
	
	protected int IdDecl.declLevel = -1;
	void IdDecl.nameAnalysis(SymbolTable<String, IdDecl> table, Semantic s) {
		super.nameAnalysis(table, s);
		declLevel = table.blockLevel();
		try {
			table.add(getId().getID(), this);
		} catch(NameError e) {
			s.addError(e);
		}
	}
	
	private String IdDecl.id = null;
	public String IdDecl.id() {
		if(id == null)
			id = getId().getID();
		return id;
	}
	private String Procedure.id = null;
	public String Procedure.id() {
		if(id == null)
			id = getId().getID();
		return id;
	}
	
	private Procedure FuncCall.declNode = null;
	public Procedure FuncCall.decl() {
		return declNode;
	}
	
	private IdDecl IdUse.declNode = null;
	public IdDecl IdUse.decl() {
		return declNode;
	}
	
	private int IdDecl.blocklevel;
	public int IdDecl.blocklevel() {
		return blocklevel;
	}
	
	private Procedure Ret.proc = null;
	public Procedure Ret.proc() {
		return proc;
	}
	
	private Procedure Procedure.parentProc = null;
	public String Procedure.label() {
		if(parentProc != null)
			return parentProc.label()+"."+id();
		return id();
	}
	
	public void IdUse.nameAnalysis(SymbolTable<String, IdDecl> table, Semantic s) {
		declNode = table.lookup(getId().getID());
		if(declNode == null)
			s.addError(new NameError("Id: "+getId().getID()+" not declared."));
	}
	
	private int Procedure.blockLevel = -1;
	public int Procedure.blockLevel() { return blockLevel; }
	public void Procedure.nameAnalysis(SymbolTable<String, IdDecl> table, Semantic s) {
		table.enterBlock();
		blockLevel = table.blockLevel();
		super.nameAnalysis(table, s);
		table.exitBlock();
	}
	
	public void ASTNode.procAnalysis(SymbolTable<String, Procedure> table, Semantic s) {
		for (int k=0; k<getNumChild(); k++) {
			getChild(k).procAnalysis(table, s);
		}
	}
		
	public void Ret.procAnalysis(SymbolTable<String, Procedure> table, Semantic s) {
		proc = s.currentProcedure();
	}
	
	public void Procedure.procAnalysis(SymbolTable<String, Procedure> table, Semantic s) {
	
		parentProc = s.currentProcedure();
		s.enterProcedure(this);
		// procedure should already be in table
		table.enterBlock();
		
		// gather the local procedures before analysis
		for (int k=0; k<getNumChild(); k++) {
			getChild(k).gatherProcedures(table, s);
		}
		
		// recurse
		for (int k=0; k<getNumChild(); k++) {
			getChild(k).procAnalysis(table, s);
		}
		
		table.exitBlock();
		s.exitProcedure();
	}
	
	public void FuncCall.procAnalysis(SymbolTable<String, Procedure> table, Semantic s) {
		String id = getId().getID();
		declNode = table.lookup(id);
		if(declNode == null)
			s.addError(new NameError("Function: "+id+" not declared.", beginLine()));
	}
	
	public void ASTNode.gatherProcedures(SymbolTable<String, Procedure> table, Semantic s) {
		for (int k=0; k<getNumChild(); k++) {
			getChild(k).gatherProcedures(table, s);
		}
	}
	
	public void Procedure.gatherProcedures(SymbolTable<String, Procedure> table, Semantic s) {
		// just add the procedure for binding, don't recurse
		try {
			table.add(id(), this);
		} catch (NameError e) {
			s.addError(e);
		}
	}
}